from flask import Flask, render_template, request, flash, redirect, url_for
from flask_sqlalchemy import SQLAlchemy
from dotenv import load_dotenv
import os
import requests
import random

load_dotenv()

# SET UP FLASK
app = Flask(__name__)
app.config['SECRET_KEY'] = os.urandom(24)

# CONNECT TO DB
app.config['SQLALCHEMY_DATABASE_URI'] = "sqlite:///mastermind.db"
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)


# SET UP DATABASE
class Slots(db.Model):
    __tablename__ = 'slots'
    id = db.Column(db.Integer, primary_key=True)
    value1 = db.Column(db.String)
    value2 = db.Column(db.String)
    value3 = db.Column(db.String)
    value4 = db.Column(db.String)
    feedback = db.Column(db.String, default='Feedback')


class Combinations(db.Model):
    __tablename__ = 'combinations'
    id = db.Column(db.Integer, primary_key=True)
    value1 = db.Column(db.Integer)
    value2 = db.Column(db.Integer)
    value3 = db.Column(db.Integer)
    value4 = db.Column(db.Integer)


db.create_all()

'''
This function will return a list of 4 random numbers from Random generator API.
'''
def generate_random_numbers(max):
    url = 'https://www.random.org/integers/'
    query = {'num': 4,
             'min': 0,
             'max': max,
             'col': 1,
             'base': 10,
             'format': 'plain',
             'rnd': 'new'
             }
    response = requests.get(url, params=query)
    string = response.text
    return list(string.replace('\n', ''))

'''
The function will update the the Combinations table and add the four values which is the Mastermind Code 
(the code that the player/user will try to guess/crack).

The parameter 'combination' is the list of random numbers generated by the API request. 
'''
def add_combination_to_db(combination):
    updated_combination = Combinations(
        value1=combination[0],
        value2=combination[1],
        value3=combination[2],
        value4=combination[3]
    )
    db.session.add(updated_combination)
    db.session.commit()

'''
This function will read the input tag using the name attribute and make a request to get a list of the user's input.
'''
def get_user_input(id):
    id_int = int(id)
    user_choice = request.form.getlist(f'slot-{id_int}')

    return user_choice

'''
This function will query the Slots table with a specific ID and returns that slot.
'''
def get_current_slot(id):
    id_int = int(id)
    slot = Slots.query.get(id_int)

    return slot

'''
This function takes in the Mastermind code as combinations, add the 4 combination values (value1 to value4) into
one list and returns that new list.
'''
def mastermind_code_to_list(combinations):
    mastermind_codes = []
    for combination in combinations:
        mastermind_codes.append(combination.value1)
        mastermind_codes.append(combination.value2)
        mastermind_codes.append(combination.value3)
        mastermind_codes.append(combination.value4)

    return mastermind_codes

'''
This function takes in a list of feedback and shuffles the elements in that list so that the player will not know
which number(s) they have guessed correctly. After shuffling the feedback list, it will add the shuffled feedback to
the feedback column at the current slot.
'''
def shuffle_feedback(feedback, slot):
    random.shuffle(feedback)
    slot.feedback = str(feedback)
    db.session.commit()

'''
Since there are 10 rows, the number of guesses starts at 10 -> 10 chances for the user to guess.
'''
number_of_guess_left = 10
'''
The default of of choices_of_numbers is 7 which means a max of 7 -> user will guess a number between 0 to 7.
'''
choices_of_numbers = 7


@app.route('/', methods=['GET', 'POST'])
def home():
    # When the home page is loaded, the Slots and Combinations Tables are created.
    db.create_all()

    if request.method == 'POST':
        # The number of guesses will always restart at 10 when a new game is played.
        global number_of_guess_left
        number_of_guess_left = 10

        global choices_of_numbers
        '''
        The user can change the max number of choices (default is max of 7). If the user wants to be challenged,
        then they have an option to change the max number of choices to 10 (numbers between 0-10) or 
        15 (numbers between 0-15).
        '''
        choices_of_numbers = request.form.get('numbers')

        '''
        Update the Combinations table by passing in the random numbers that's been generated.
        '''
        add_combination_to_db(generate_random_numbers(int(choices_of_numbers)))

        '''
        There will always be 10 rows with 4 slots (columns). The 4 slots (columns) will always start with a value of ''.
        '''
        for i in range(10):
            slot = Slots(
                value1='',
                value2='',
                value3='',
                value4=''
            )
            db.session.add(slot)
            db.session.commit()

        return redirect(url_for('mastermind'))

    return render_template('home-page.html')


@app.route('/mastermind', methods=['GET', 'POST'])
def mastermind():
    # The number of guesses is initiated at 10 since there are 10 rows -> 10 chances for the user to guess.
    global number_of_guess_left
    global choices_of_numbers
    feedbacks = []
    winner = False
    game_over = False
    user_score = 0

    '''
    The Slots table is queried so that it will return a list of records. The list of records will then be rendered
    in the index.html template to display 10 rows of input fields.
    '''
    slots = Slots.query.all()
    combinations = Combinations.query.all()

    codes = mastermind_code_to_list(combinations)

    # When 'CHECK' button is clicked...
    if request.method == 'POST':
        slot_clicked = request.form['slot-clicked']  # return the value attribute of the button element (specific slot ID)
        slot = get_current_slot(slot_clicked)  # query the Slots table by filtering the ID received from slot_clicked
        user_choice = get_user_input(slot_clicked)  # return the list of user input by passing in the slot ID

        if len(user_choice) == 0:   # If the user did not input anything on the input field, error message is displayed.
            flash(f'Please enter a number between 0-{choices_of_numbers}')
        elif '' in user_choice:  # If the user left one of the slots blank, then an error message is displayed.
            flash(f'Please enter a number between 0-{choices_of_numbers}')
        else:  # If the user input is within constraints (entered a number between 0-7), then each user input is saved.
            slot.value1 = (user_choice[0])
            slot.value2 = (user_choice[1])
            slot.value3 = (user_choice[2])
            slot.value4 = (user_choice[3])
            '''
            The number_of_guess_left variable is then subtracted using the slot ID information since that 
            is where the user is currently making a guess.
            '''
            number_of_guess_left = 10-slot.id
            db.session.commit()

            '''
            Feedback:
                1 = Correct position
                2 = User input is in Mastermind's code, but wrong position.
            '''
            # CHECK IF USER INPUT IS IN THE CORRECT position
            '''
            If the user_input is in the CORRECT position, then we will replace the number in the Mastermind's 
            combination code (codes) with an indicator such as 'X', and the user_choice at the current index (i) to an 
            indicator such as '-'.
            '''
            for i, user_input in enumerate(user_choice):
                if int(user_input) == codes[i]:
                    codes[i] = 'X'
                    user_choice[i] = '-'
                    feedbacks.append('1')
            shuffle_feedback(feedbacks, slot)  # shuffle the feedbacks so users will not know which numbers are correct

            # CHECK IF USER INPUT IS IN THE MASTERMIND CODE
            '''
            With the updated user_choice and codes (containing indicators), we first check if user_input is '-',
            if so, then that means that number has been checked indicating that it is in the correct position already, 
            therefore, we can just continue with our iteration because there is no need to provide additional feedback.
            
            If the user_input is NOT an indicator (i.e. '-'), we then check if the user_input is one of the 
            Mastermind's codes (codes). If so, then we need to locate the index of the user_input inside the codes list
            and update using the same indicators.
            '''
            for i, user_input in enumerate(user_choice):
                if user_input == '-':
                    continue
                elif int(user_input) in codes:
                    user_input_index = codes.index(int(user_input))
                    codes[user_input_index] = 'X'
                    user_choice[i] = '-'
                    feedbacks.append('2')
            shuffle_feedback(feedbacks, slot)  # shuffle the feedbacks so users will not know which numbers are correct

            '''
            Check if feedback has four '1's in the list. If so, then that means that the user has guess the correct code
            '''
            counter = 0
            for feedback in feedbacks:
                if feedback == '1':
                    counter += 1

            if counter == 4:
                winner = True
                user_score = 10 - number_of_guess_left
            elif number_of_guess_left == 0:
                game_over = True

    return render_template('index.html', slots=slots, winner=winner, input_max=choices_of_numbers,
                           mastermind_code=mastermind_code_to_list(combinations),
                           number_of_guess_left=number_of_guess_left, game_over=game_over, user_score=user_score)


@app.route('/mastermind/review')
def review():
    slots = Slots.query.all()

    return render_template('game-review.html', slots=slots)

'''
When the game ends whether the player has won or lost, the Slots and Combinations Tables will be deleted so that when a
player starts a new game, the previous data is dropped.
'''
@app.route('/play')
def play_again():
    engine = db.engine
    Slots.__table__.drop(engine)
    Combinations.__table__.drop(engine)

    return redirect(url_for('home'))

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
